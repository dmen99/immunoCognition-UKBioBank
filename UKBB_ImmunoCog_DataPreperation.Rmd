---
title: "UKBB_ImmunoCog_Analysis"
author: "Daniel Mendelson"
date: "22/02/2022"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(stringr)
library(dplyr)
library(tidyr)
library(arsenal)
library(reticulate)
library(psych)
library(lubridate)
library(glue)
library(knitr)
library(finalfit)
library(Hmisc)
library(DescTools)
knitr::knit_engines$set(python = reticulate::eng_python)
reticulate::virtualenv_create(envname = "myreticulate", python = "/usr/bin/python3.8", packages = "pandas")

outputPath <- "/home/doodlefish/Documents/Research/LepageLab/immunologyAndSz/Analysis/immunoCognition/Outputs" # working directory to desired output location
setwd(outputPath)
date <- str_c(format(Sys.time(), "%m"), "_", format(Sys.time(), "%d"), "_", format(Sys.time(), "%Y")) # set todays date for easier output filenaming
```

# 0 - Functions

## Assumption checks

### Normality

```{r normalityCheck, echo=FALSE}
numNotFactor <- function(x){
  if(is.numeric(x) == TRUE && is.factor(x) == FALSE && is.logical(x) == FALSE){
          return(x)
  }
} # This function is made to be used by mapply(). 'x' - a column from a df.

normalCheck <- function(x, colName, colNum){
  plotList <- c()
  
  degFree <- length(x)
  skew <- skew(x)
  se_skew <- skew/length(x)
  t_skew <- skew/se_skew
  p_skew <- pt(q = abs(t_skew), df = degFree, lower.tail = F)
  skewReport <- paste("skew=", round(skew, 2), "(t=", format(round(t_skew, 2), scientific = T), ", p=", format(round(p_skew, 2), scientific = T), ")")
    
  kurt <- kurtosi(x)
  se_kurt <- sqrt(24/degFree)
  t_kurt <- kurt/se_kurt
  p_kurt <- pt(q = abs(t_kurt), df = degFree, lower.tail = F)
  kurtReport <- paste("kurt=", round(kurt, 2), "(t=", format(round(t_kurt, 2), scientific = T), ", p=", format(round(p_kurt, 2), scientific = T), ")")
  
  layout(matrix(c(1,2), ncol = 2, nrow = 1))
  hist <- hist(x, xlab = "",main = paste("Hist - ", colNum, colName), sub = paste("colNum: ", colNum, skewReport, "\n", "colNum: ", colNum, kurtReport))
  qqplot <- qqnorm(x, main = paste("QQplot - ", colNum, colName))
  qqline(x)
  iPlots <- list(hist, qqplot)
  plotList <- append(plotList, iPlots)
  return(plotList)
} # This function is made to be used by mapply(). 'x' - a column from a df; 'colName' - a string specifying the name of this column; 'colNum' - a number specifying the column number of this variable in df

```

## PCA function

```{r PCAFx, echo=FALSE}
PCACompute <- function(df, vars){
  # PCA (see 536 lecture notes week 10) ---------
  rejectVars <- c()
  for(i in vars){
    if(is.numeric(as.matrix(df[[i]])) == FALSE){ # checks that variables are numeric
        rejectVars <- append(rejectVars, i)
    } else {
        mean <- mean(as.matrix(df[i]), na.rm = T)
        sd <- sd(as.matrix(df[i]), na.rm = T)
        
        if(round(mean,4) != 0 || round(sd,4) != 1){ # check if standardized
          df[i] <- scale(df[i])
          # print(c("Not standard.",colnames(df[i]), typeof(as.matrix(df[i])))) 
          # print(c(mean(as.matrix(df[i]), na.rm = T), sd(as.matrix(df[i]), na.rm = T)))
        } else {
          # print(c("Yes.",colnames(df[i]), typeof(as.matrix(df[i]))))   
          # print(c(mean(as.matrix(df[i]), na.rm = T), sd(as.matrix(df[i]),na.rm = T)))
        }
    }
  }
  
  if(length(rejectVars) > 0){
      cat("The following variables are not numeric and cannot be included in PCA. \n\t")
      for(i in colnames(df[rejectVars])){
        cat(i, "\t")
      }
     vars <- vars[vars %in% rejectVars == FALSE] # removes the reject variables from the 'vars' list
  }
  
  out <- prcomp(as.matrix(df[,vars]), center = TRUE, scale = TRUE) # prints output
  return(out)
  
} # 'df' - dataframe; 'vars' - name of vars to conduct PCA on. N.B. these variables must be standardized before being entered here.

PCAPlot <- function(PCAOut, name){
  require(factoextra)
  
  screePlot <- fviz_eig(PCAOut,
                  choice = c("eigenvalue"),
                  geom = c("line"),
                  linecolor = "black",
                  ncp = 10,
                  addlabels = TRUE,
                  hjust = 0,
                  main = paste("Scree plot - ", name),
                  xlab = "Principal component",
                  ylab = NULL) +
              geom_hline(yintercept = 1, linetype = 2)

  return(screePlot)

} # 'PCAOut' - an object of class PCA (i.e., from the PCA compute function); 'name' - name of this PCA analysis

PCAApply <- function(df, PCAOut, componentsToRetain, prefix){
  
  varCols <- which(colnames(df) %in% names(PCAOut$rotation[,1]))
  df_z <- df %>% 
    as_tibble() %>% 
    mutate_at(varCols, ~(scale(.) %>% as.vector))
  
  for(i in 1:componentsToRetain){
    rowName <- paste(prefix, "PC", i, sep="_")
    df_z <- df_z %>% 
      mutate("{{rowName}}" := as.matrix(df_z[varCols]) %*% PCAOut$rotation[,i])
  }
  
  return(df_z)
  
} # Gives each observation a score for each PCA component retained. 'df' - dataframe; 'PCAOut' - output from the PCACompute function; 'componentsToRetain' - an integer value specifying the number of principal components to retain (value must be between 1 and total number of components)); 'prefix' - a character string to be used as a prefix for the new column names.

PCASave <- function(PCAOut, fileName){
  fileName <- paste(fileName, "_", date, ".csv", sep="") 
  capture.output(PCAOut$rotation, file = fileName)
}
  
```

# -------------------------------

# 1 - Biobank data analysis

## Data Preperation

```{r removeEIDs, echo=FALSE}
# df_all <- read_csv("/home/doodlefish/Documents/Research/LepageLab/immunologyAndSz/Data/CCData/Daniel_2022-03-17.csv") # import df
# eidToRemove <- read_csv("/home/doodlefish/Documents/Research/LepageLab/immunologyAndSz/Data/CCData/eidToRemove-w45551_20220222.csv", col_names = "eid") # file with EID of participants who withdrew consent from UKBB
# 
# df_all <- df_all %>% filter(!(eid %in% eidToRemove)) # remove rows with eid in this file
# write.csv(df_all, "/home/doodlefish/Documents/Research/LepageLab/immunologyAndSz/Data/CCData/Daniel_2022-03-17_ProperEID.csv", row.names=FALSE)
# rm(df_all, eidToRemove) # remove dataframes not in use

```

```{r dataPrep, echo=FALSE}
df_all <- read_csv("/home/doodlefish/Documents/Research/LepageLab/immunologyAndSz/Data/CCData/Daniel_2022-03-17_ProperEID.csv", guess_max = 10000) # import df
         
# cat(paste("There are ", sum(is.na(df_all$date_assess2_t2)), "cases that have not completed time point 2. These cases will be removed."))
# df_all <- df_all %>% 
#   filter(!(is.na(df_all$date_assess2_t2))) # remove rows without timepoint 2 assessment date

# df_small <- df_all[1:10000,]
df <- df_all # specifies what df to use. In final analyses will want to use df_all but want to use smaller df while developing code.
# rm(df_small) # remove dataframes not in use
# sort(colnames(df))
```

### Standardize categorical vars
```{r standardizeCatVars, echo=FALSE}
# standardize categorical variable responses
df <- df %>% 
  transform(sleep_duration2_t2 = as.character(sleep_duration2_t2))

df <- df %>%
  mutate(diet_cookedVeg_t0 = case_when(  # for field: 1289 ('diet_cookedVeg'), -10 = Less than one; -1 = Do not know; -3 = Prefer not to answer;  
      diet_cookedVeg_t0 == "Less than one" ~ "0.5",       
      diet_cookedVeg_t0 == "Do not know" ~ "NA",       
      diet_cookedVeg_t0 == "Prefer not to answer" ~ "NA",
      TRUE ~ diet_cookedVeg_t0
  )) %>% 
  mutate(diet_fruit_t0 = case_when( # for field: 1309 ('diet_fruit'), -10 = Less than one; -1 = Do not know; -3 = Prefer not to answer;  
      diet_fruit_t0 == "Less than one" ~ "0.5",       
      diet_fruit_t0 == "Do not know" ~ "NA",       
      diet_fruit_t0 == "Prefer not to answer" ~ "NA",
      TRUE ~ diet_fruit_t0
  )) %>% 
  mutate(diet_rawVeg_t0 = case_when( # for field: 1299 ('diet_rawVeg'), -10 = Less than one; -1 = Do not know; -3 = Prefer not to answer;
      diet_rawVeg_t0 == "Less than one" ~ "0.5",       
      diet_rawVeg_t0 == "Do not know" ~ "NA",       
      diet_rawVeg_t0 == "Prefer not to answer" ~ "NA",
      TRUE ~ diet_rawVeg_t0
  )) %>%
  mutate(diet_processedMeat_t0 = case_when( # field 1349 ('diet_processedMeat'), -1 = Do not know; -3 = Prefer not to answer;
      diet_processedMeat_t0 == "Do not know" ~ "NA",       
      diet_processedMeat_t0 == "Prefer not to answer" ~ "NA",
      TRUE ~ diet_processedMeat_t0
  )) %>% 
  mutate(diet_water_t0 = case_when( # field 1528 ('diet_water'), -10 = Less than one; -1 = Do not know; -3 = Prefer not to answer;
      diet_water_t0 == "Less than one" ~ "0.5",       
      diet_water_t0 == "Do not know" ~ "NA",       
      diet_water_t0 == "Prefer not to answer" ~ "NA",
      TRUE ~ diet_water_t0
  )) %>%
  mutate(diet_alc_freq_t0 = case_when( # field 1558 ('cog_numMem_maxDigitRemem_t2'), -3 = Prefer not to answer;
    cog_numMem_maxDigitRemem_t2 == "Prefer not to answer" ~ "NA",
    TRUE ~ cog_numMem_maxDigitRemem_t2 
    )) %>% 
  mutate(menopause_t0 = case_when( # field 2724 ('menopause'), -3 = Prefer not to answer;
      menopause_t0 == "Prefer not to answer" ~ "NA",
      TRUE ~ menopause_t0
  )) %>%
  mutate(sleep_duration0_t0 = case_when( # field 1160 ('sleep_duration'), -1 = Do not know; -3 = Prefer not to answer;
      sleep_duration0_t0 == "Prefer not to answer" ~ "NA",
      sleep_duration0_t0 == "Do not know" ~ "NA",
      TRUE ~ sleep_duration0_t0
  )) %>%
  mutate(sleep_duration2_t2 = case_when( # field 1160 ('sleep_duration'), -1 = Do not know; -3 = Prefer not to answer;
      sleep_duration2_t2 == "Prefer not to answer" ~ "NA",
      sleep_duration2_t2 == "Do not know" ~ "NA",
      TRUE ~ sleep_duration2_t2
  )) %>%
   mutate(smoke_currently_t0 = case_when( # field 2724 ('smoke_currently'), -3 = Prefer not to answer;
      smoke_currently_t0 == "Prefer not to answer" ~ "NA",
      smoke_currently_t0 == "No" ~ smoke_currently_t0,
      TRUE ~ "Yes"
  )) %>%
  mutate(smoke_packYears_t0 = case_when( # field 2724 ('smoke_currently'), -3 = Prefer not to answer;
      smoke_ever_t0 == "No" ~ 0,
      TRUE ~ smoke_packYears_t0
  )) %>%
  mutate(cog_TMT_numericDuration_t2 =  case_when( # fields: 6348 ('cog_TMT_numericDuration'), 6350 ('cog_TMT_alphanumDuration'), 0 = trail not completed
    cog_TMT_numericDuration_t2 == "trail not completed" ~ "NA",
    TRUE ~ cog_TMT_numericDuration_t2
  )) %>% 
  mutate(cog_TMT_alphanumDuration_t2 =  case_when(
    cog_TMT_alphanumDuration_t2 == "trail not completed" ~ "NA",
    TRUE ~ cog_TMT_alphanumDuration_t2
  )) %>% 
  mutate(cog_numMem_maxDigitRemem_t2 = case_when( # field 4282 ('cog_numMem_maxDigitRemem_t2'), -1 = abandoned
    cog_numMem_maxDigitRemem_t2 == "abandoned" ~ "NA",
    TRUE ~ cog_numMem_maxDigitRemem_t2
  )) %>% 
  mutate(demo_ethnicity_t0 = case_when( # field 4282 ('cog_numMem_maxDigitRemem_t2'), -1 = abandoned
    demo_ethnicity_t0 == "Prefer not to answer" ~ "NA",
    demo_ethnicity_t0 == "Do not know" ~ "NA",
    demo_ethnicity_t0 == "British" ~ "White",
    demo_ethnicity_t0 == "Irish" ~ "White",
    demo_ethnicity_t0 == "Any other white background" ~ "White",
    demo_ethnicity_t0 == "Bangladeshi" ~ "South Asian",
    demo_ethnicity_t0 == "Indian" ~ "South Asian",
    demo_ethnicity_t0 == "Pakistani" ~ "South Asian",
    demo_ethnicity_t0 == "Bangladeshi" ~ "South Asian",
    demo_ethnicity_t0 == "African" ~ "African/Caribbean",
    demo_ethnicity_t0 == "Caribbean" ~ "African/Caribbean",
    demo_ethnicity_t0 == "Chinese" ~ "East Asian",
    demo_ethnicity_t0 == "Asian or Asian British" ~ "Other ethnic group",
    demo_ethnicity_t0 == "Black or Black British" ~ "Other ethnic group",
    demo_ethnicity_t0 == "Any other Asian background" ~ "Other ethnic group",
    demo_ethnicity_t0 == "Any other Black background" ~ "Other ethnic group",
    demo_ethnicity_t0 == "White and Black African" ~ "Mixed",
    demo_ethnicity_t0 == "White and Black Caribbean" ~ "Mixed",
    demo_ethnicity_t0 == "White and Asian" ~ "Mixed",
    demo_ethnicity_t0 == "Any other mixed background" ~ "Mixed",
    TRUE ~ demo_ethnicity_t0
    ))
```

### Add columns

```{r addColumns, echo=FALSE}
# Waist:hip ratio -----
df <- df %>% 
  mutate(weight_waistToHip = weight_waistCirc_t0/weight_hipCirc_t0)

# CRP log transform ------
df <- df %>% 
  mutate(crp_log = log(crp_aliquot_t0))

# Diagnosis - any of interest -----
dxVars <- starts_with("dx_", vars = colnames(df))

df <- df %>% 
  mutate("dx_AnyOfInterest" = factor(case_when(
    if_any(any_of(dxVars), function(x) (x == "TRUE")) ~ 1,
    if_all(all_of(dxVars), function(x) (x == "FALSE")) ~ 0)))
dxVars <- c(dxVars, which(colnames(df) == "dx_AnyOfInterest"))

dxVarsNoCases <- c()
for(i in dxVars){
  if(levels(as.factor(df[i])) == FALSE){
    print(paste("No participant has dx ", colnames(df[i]), "(column ", i, " ); levels: ", levels(as.factor(df[i]))))
    dxVarsNoCases <- append(dxVarsNoCases, i)
  }
}
if(is.null(dxVarsNoCases) == FALSE){
  for(i in dxVarsNoCases){
    dxVars <- dxVars[-which(dxVars == i)]
  }
}
# table(df$anyDx)

# Medication - any of interest -----------
medVars <- starts_with("med_", vars = colnames(df))

medVars0 <- ends_with("0", vars = colnames(df[medVars]))
medVars0 <- which(colnames(df) %in% colnames(df[medVars[medVars0]]))

medVars2 <- ends_with("2", vars = colnames(df[medVars]))
medVars2 <- which(colnames(df) %in% colnames(df[medVars[medVars2]]))

df <- df %>% 
  mutate("med_AnyOfInterest0" = factor(case_when(
    if_any(any_of(medVars0), function(x) (x == "TRUE")) ~ 1,
    if_all(all_of(medVars0), function(x) (x == "FALSE")) ~ 0))) %>% 
  mutate("med_AnyOfInterest2" = factor(case_when(
    if_any(any_of(medVars2), function(x) (x == "TRUE")) ~ 1,
    if_all(all_of(medVars2), function(x) (x == "FALSE")) ~ 0)))
medVars0 <- c(medVars0, which(colnames(df) == "med_AnyOfInterest0"))

medVars0NoCases <- c()
for(i in medVars0){
  if(levels(as.factor(df[i])) == FALSE){
    print(paste("No participant takes med ", colnames(df[i]), "; levels: ", levels(as.factor(df[i]))))
    medVars0NoCases <- append(medVars0NoCases, i)
  }
}

medVars2 <- c(medVars2, which(colnames(df) == "med_AnyOfInterest2"))
medVars2NoCases <- c()
for(i in medVars2){
  if(levels(as.factor(df[i])) == FALSE){
    print(paste("No participant takes med ", colnames(df[i]), "; levels: ", levels(as.factor(df[i]))))
    medVars2NoCases <- append(medVars2NoCases, i)
  }
}

if(is.null(medVars0NoCases) == FALSE){
  for(i in medVars0NoCases){
    medVars0 <- medVars0[-which(medVars0 == i)]
  }
}
if(is.null(medVars2NoCases) == FALSE){
  for(i in medVars2NoCases){
    medVars2 <- medVars2[-which(medVars2 == i)]
  }
}
# table(df$anyMed)

# Num days between assessment 2 and assessment 0 ---------
df <- df %>% 
  mutate(demo_daysBtwAssess = as.numeric(df$date_assess2_t2 - df$date_assess0_t0, units = "days"))

# Hour of day of assessments -----------
# Goal: take variables with form: 'YYYY-MM-DDTHH:MM:SS' and return the hour
df <- df %>% 
  mutate(crp_hourCollected = hour(df$crp_timeCollected_t0)) %>% 
  mutate(cog_hourCompleted = hour(df$cog_timeCompleted_t2)) %>% 
  mutate(brain_hourCompleted = hour(df$brain_timeCompleted_t2))

# df <- df %>% mutate(timeDif_brainHourMinusCogHourCompleted = df[124] - df[123]) # number of hours difference between cognitive assessment and MRI
# hourColNums <- c(contains("_hourCompleted", vars = colnames(df)),contains("_hourCollected", vars = colnames(df)))

```

### Make columns appropriate data types

```{r colType, echo=FALSE}
df <- readr::type_convert(df) # automatically detect
factorVars <- which(colnames(df) %in% c("demo_sex_t0", "demo_ethnicity_t0", "cog_prospMem_result_t2", "hand_t0","smoke_currently_t0", "menopause_t0", "anyMedOfInterest0", "anyMedOfInterest2", "anyDxOfInterest", "med_SSRI0", "med_SSRI2", dxVars, medVars0, medVars2)) # Factors
df[,factorVars] <- lapply(df[,factorVars], factor) # at this line the df size is read as 0 B for some reason. This does not appear to affect the data however.

df <- df %>% 
  mutate(crp_aliquot_fctr = cut(crp_aliquot_t0, # CRP cutoffs (see Pearson et al., 2003)
                       breaks = c(0,1,3,10),
                       labels = c("Low", "Medium", "High"),
                       include.lowest = T,
                       right = F), .after = crp_aliquot_t0
  ) %>% 
    mutate(cog_prospMem_result_t2 = case_when( # field 20018 ('cog_prospMem_result_t2'), 0 = instruction not recalled, either skipped or incorrect; 1 = correct recall on first attempt; 2 = correct recall on second attempt (as in Cullen et al., 2017)
    cog_prospMem_result_t2 == "correct recall on first attempt" ~ "1",
    cog_prospMem_result_t2 == "NA" ~ "NA",
    TRUE ~ "0" 
    )) %>% mutate(cog_prospMem_result_t2  = as.numeric(cog_prospMem_result_t2))

df <- df %>%
  mutate(smoke_currently_t0 = factor(smoke_currently_t0, order = F, levels = c(
                                       "No",
                                       "Yes"))) %>% 
  mutate(diet_processedMeat_t0 = factor(diet_processedMeat_t0, order = T, levels = c(
                                       "Never",
                                       "Less than once a week",
                                       "Once a week", 
                                       "2-4 times a week",
                                       "5-6 times a week",
                                       "Once or more daily"))) %>% 
  mutate(diet_alc_freq_t0 = factor(diet_alc_freq_t0, order = T, levels = c(
                                       "Never",
                                       "Special occasions only",
                                       "One to three times a month",
                                       "Once or twice a week",
                                       "Three or four times a week",
                                       "Daily or almost daily"))) %>% 
  mutate(exercise_IPAQActivityGroup_t0 = factor(exercise_IPAQActivityGroup_t0, order = T, levels = c(
                                       "low", 
                                       "moderate",
                                       "high"))) %>% 
  mutate(ses_houseIncome2_t2 = factor(ses_houseIncome2_t2, order = T, levels = c(
                                       "Less than 18,000",
                                       "18,000 to 30,999",
                                       "31,000 to 51,999",
                                       "52,000 to 100,000",
                                       "Greater than 100,000"))) %>% 
  mutate(med_SSRI0 = factor(case_when(
         med_SSRI0 == "FALSE" ~ 0,
         med_SSRI0 == "TRUE" ~ 1))) %>% 
  mutate(med_SSRI2 = factor(case_when(
         med_SSRI2 == "FALSE" ~ 0,
         med_SSRI2 == "TRUE" ~ 1))) %>% 
  mutate(med_AnyOfInterest2 = factor(med_AnyOfInterest2))
  
df <- readr::type_convert(df) # automatically detect
```

## Remove cases with missing variables
```{r variableLists, echo=FALSE}
demoVars <- starts_with("demo_", vars = colnames(df))
sesVars <- starts_with("ses_", vars = colnames(df))
crpAliqVars <- starts_with("crp_aliquot", vars = colnames(df))
brainVolVars <- starts_with("brain_vol", vars = colnames(df))
cogVars <- starts_with("cog_", vars = colnames(df))

dietVars <- starts_with("diet_", vars = colnames(df))
dietVarsToCor <- which(colnames(df) %in% c("diet_cookedVeg_t0","diet_rawVeg_t0","diet_fruit_t0","diet_processedMeat_t0","diet_water_t0"))

smokingVars <- starts_with("smoke_", vars = colnames(df))
weightVars <- c(starts_with("weight_", vars = colnames(df)), which(colnames(df) == "waistToHip"))
exerciseVars <- starts_with("exercise_", vars = colnames(df))

completionTimeVars <- c(contains("timeCompleted", vars = colnames(df)), contains("timeCollected", vars = colnames(df)))
cogPCAVars <- which(colnames(df) %in% c("cog_numMem_maxDigitRemem_t2", "cog_TMT_numericDuration_t2", "cog_TMT_numericErrors_t2", "cog_TMT_alphanumDuration_t2", "cog_TMT_alphanumErrors_t2", "cog_matrix_cor_t2", "cog_reactiontime_mean_t2", "cog_tower_cor_t2", "cog_digsub_cor_t2"))

finalCovars <- which(colnames(df) %in% c("demo_sex_t0", "demo_ethnicity_t0", "demo_age_assess0_t0", "demo_daysBtwAssess","waistToHip_z"))

# colnames(df[sesVars])
# View(df[1:100, c(1,cogPCAVars)])
```

```{r removeMissing, echo=FALSE}
essentialVars <- c(demoVars, completionTimeVars, crpAliqVars, cogPCAVars, brainVolVars, finalCovars) # list of variable names that must be complete in order for case to be retained
df <- df %>% 
  mutate(missingEssentialVar = case_when(
    if_any(any_of(essentialVars), function(x)(
      is.na(x))) ~ "Remove",
      TRUE ~ "Keep" )) %>% 
  mutate(missingEssentialVar = factor(missingEssentialVar))

table(df$missingEssentialVar)

df_removed <- df %>%
  filter(if_any(any_of(essentialVars), function(x)(is.na(x)))) # add rows with missing values to new df

# df <- df %>% 
#   filter(!(eid %in% df_removed$eid)) # remove rows of those with missing values
```

Critical variables: `r colnames(df[essentialVars])` `r nrow(df_removed)` unique cases have missing values for critical variables and will thus be removed.

```{r missingValues, echo=FALSE}
numMissing <- matrix(ncol=2, nrow = length(essentialVars), dimnames = list(colnames(df_removed[essentialVars]), c("NACount", "NotNA")))

for(i in 1:length(essentialVars)){
  numMissing[i,] <- c(sum(is.na(df_removed[essentialVars[i]])), sum(!is.na(df_removed[essentialVars[i]])))
}

numMissing_df <- as.data.frame(numMissing) %>%  arrange(desc(NACount))

kable(numMissing_df, caption = paste("Number of missing cases per variable. Number of rows with at least one missing value: ", nrow(df_removed), " out of ", sum(df$missingEssentialVar == "Keep")+nrow(df_removed), " total cases (", round(nrow(df_removed)/(sum(df$missingEssentialVar == "Keep")+nrow(df_removed))*100, 2), "%).", sep = ""))

```

### Normality
```{r normalityInRetained, echo=FALSE}
df_retained <- df %>%
  filter(!(eid %in% df_removed$eid)) # remove rows of those with missing values

varsToCompare <- c("demo_sex_t0", "demo_birthYear_t0", "demo_ethnicity_t0", "demo_age_assess0_t0", "demo_age_assess2_t2", "ses_townsend_t0", "crp_aliquot_t0", "crp_log", "med_AnyOfInterest0", "med_SSRI0", "smoke_currently_t0", "exercise_IPAQActivityGroup_t0", "weight_BMI0_t0", "weight_waistToHip", "diet_processedMeat_t0", "sleep_duration0_t0", "menopause_t0", "hand_t0")

varsToCompare_ColNum <- which(colnames(df) %in% varsToCompare)

for(i in c(medVars0NoCases, medVars2NoCases, dxVarsNoCases)){
  if(is.null(i) == FALSE){
    if(i %in% varsToCompare_ColNum){
      colNum <- which(colnames(df) == colnames(df[i]))
      varsToCompare_ColNum <- varsToCompare_ColNum[-which(varsToCompare_ColNum == colNum)]
    }
  }
}

if("dx_CVD.1" %in% colnames(df[varsToCompare_ColNum])){
  colNum <- which(colnames(df[varsToCompare_ColNum]) == "dx_CVD.1")
  varsToCompare_ColNum <- varsToCompare_ColNum[-which(varsToCompare_ColNum == colNum)]
}

# create list of non-factor numeric variables for normality check ----
numVarsToCompare <- lapply(df[varsToCompare_ColNum], numNotFactor)
df_numVarsToCompare <- as.data.frame(do.call(cbind, numVarsToCompare))
numVarColsToCompare <- (which(colnames(df) %in% colnames(df_numVarsToCompare)))

# For each variable in this list, determine if normal --------
normalityPlots <- mapply(normalCheck, df[numVarColsToCompare], colName = colnames(df[numVarColsToCompare]), colNum = numVarColsToCompare)
# N.b. QQ plot should follow a straight line
# nonParametricVars <- c(3,4,5,9,15,16, 17,19,36,38,41,43,49,56,57,58,66,67,69,101) # vector specifying which values of dependent to run non-parametric tests on 
nonParametricVars <- c(3,9,12,38,40,41,69)
```

### Compare removed cases to retained cases

```{r compareMissing, echo=FALSE}
nonParaDep <- which(varsToCompare %in% colnames(df[nonParametricVars]))

summaryMissing <- list()
nonPara <- c()
for(i in varsToCompare){
  if(i %in% nonParaDep == TRUE){
    nonPara <- i
  }
  newRow <- df %>% 
    summary_factorlist(dependent = i, explanatory = "missingEssentialVar", cont = "median", cont_nonpara = nonPara, p = T, p_cat = "chisq", add_dependent_label = T, add_col_totals = T, add_row_totals = T, na_include = F)
  # print(newRow)
  summaryMissing <- c(summaryMissing, newRow)
}
capture.output(summaryMissing, file = paste("UKBB_compareMissingCases_", date, ".csv", sep = ""))
# save(summaryMissing, file = paste("UKBB_compareMissingCases", date, ".csv"))

comparisonDroppedCases <- TOne(df[varsToCompare], grp = df$missingEssentialVar, add.length = T, total = T, 
          FUN = function(x) gettextf("%s (%s); %s (%s)",
            Format(mean(x, na.rm = T), digits = 3),
            Format(sd(x, na.rm = T), digits = 3),
            Format(median(x, na.rm = T), digits = 3),
            Format(IQR(x, na.rm = T), digits = 3)),
          TEST = list(
            num  = list(fun = function(x, g){summary(aov(x ~ g))[[1]][1, "Pr(>F)"]},
                        lbl = "ANOVA"),
            cat  = list(fun = function(x, g){chisq.test(table(x, g))$p.val},
                        lbl = "Chi-Square test"),
            dich = list(fun = function(x, g){chisq.test(table(x, g))$p.val},
                        lbl = "Chi-Square test")), 
          fmt = list(abs  = Fmt("abs"), 
             num  = Fmt("num"), 
             per  = Fmt("per"),
             pval = as.fmt(fmt = "p*")))
write.csv(comparisonDroppedCases, file = paste("UKBB_compareMissingCases_TOne", date, ".csv", sep = ""))
kable(comparisonDroppedCases)
```

### Summarise
```{r saveDf, echo=FALSE}
df <- df_retained
# write.csv(df_retained, file = paste("UKBB_dfRetained_", date, ".csv", sep = "")) # exports wilcoxOutput to a CSV file
varsToSummarise <- c(1:ncol(df))
  
numVars<- lapply(df, numNotFactor)
df_numVars <- as.data.frame(do.call(cbind, numVars))
numVarCols <- (which(colnames(df) %in% colnames(df_numVars)))
numVars <- c((which(colnames(df) %in% colnames(df_numVars))), which(colnames(df) == "date_assess0_t0"), which(colnames(df) == "date_assess2_t2"), which(colnames(df) == "cog_timeCompleted_t2"), which(colnames(df) == "brain_timeCompleted_t2"), which(colnames(df) == "crp_timeCollected_t0"), which(colnames(df) == "crp_assaydate_t0"))

for(i in c(medVars0NoCases, medVars2NoCases, dxVarsNoCases)){
  if(is.null(i) == FALSE){
    if(i %in% varsToSummarise){
      colNum <- which(colnames(df) == colnames(df[i]))
      varsToSummarise <- varsToSummarise[-which(varsToSummarise == colNum)]
    }
  }
}

write.csv(describeBy(df[numVars], group = df$crp_aliquot_fctr)[1], file = paste("UKBB_dfRetained_Summary_byCRP_numVars_", names(describeBy(df, group = df$crp_aliquot_fctr)[1]), "_", date, ".csv", sep = "")) # save counts of categorical variables
write.csv(summary(df[-numVars]), file = paste("UKBB_dfRetained_Summary_fctrVars", date, ".csv", sep = "")) # save counts of categorical variables

write.csv(describeBy(df[numVars], group = df$crp_aliquot_fctr)[1], file = paste("UKBB_dfRetained_Summary_byCRP_numVars_", names(describeBy(df, group = df$crp_aliquot_fctr)[1]), "_", date, ".csv", sep = "")) # save counts of categorical variables
write.csv(describeBy(df[numVars], group = df$crp_aliquot_fctr)[2], file = paste("UKBB_dfRetained_Summary_byCRP_numVars_", names(describeBy(df, group = df$crp_aliquot_fctr)[2]), "_", date, ".csv", sep = "")) # save counts of categorical variables
write.csv(describeBy(df[numVars], group = df$crp_aliquot_fctr)[3], file = paste("UKBB_dfRetained_Summary_byCRP_numVars_", names(describeBy(df, group = df$crp_aliquot_fctr)[3]), "_", date, ".csv", sep = "")) # save counts of categorical variables

capture.output(Hmisc::describe(df[-numVars]), file = paste("UKBB_dfRetained_Summary_fctrVars", date, ".tex", sep = "")) # save counts of categorical variables to latex file

TOne(df[varsToSummarise], grp = df$crp_aliquot_fctr, add.length = T, colnames = colnames(df[varsToSummarise]), total = T, # need to find which categorical variable is causing an error here. colnames(df[! colnames(df[varsToSummarise]) %in% colnames(df[varsToCompare])])
     FUN = function(x) gettextf("%s (%s); %s (%s)",
            Format(mean(x, na.rm = T), digits = 3),
            Format(sd(x, na.rm = T), digits = 3),
            Format(median(x, na.rm = T), digits = 3),
            Format(IQR(x, na.rm = T), digits = 3)),
     TEST = list(
            num  = list(fun = function(x, g){summary(aov(x ~ g))[[1]][1, "Pr(>F)"]},
                        lbl = "ANOVA"),
            cat  = list(fun = function(x, g){chisq.test(table(x, g))$p.val},
                        lbl = "Chi-Square test"),
            dich = list(fun = function(x, g){chisq.test(table(x, g))$p.val},
                        lbl = "Chi-Square test")), 
           fmt = list(abs  = Fmt("abs"), 
                   num  = Fmt("num"), 
                   per  = Fmt("per"),
                   pval = as.fmt(fmt = "p*")))

# possibleErrorVars <- df[! colnames(df[varsToSummarise]) %in% colnames(df[varsToCompare])]
# possibleErrorVarsNum <- lapply(possibleErrorVars, numNotFactor)
# df_possibleErrorVars <- as.data.frame(do.call(cbind, possibleErrorVars))
# possibleErrorVarsCols <- (which(colnames(df) %in% colnames(df_possibleErrorVars)))
# df_possibleErrorVarsfctr <- df[varsToSummarise][-possibleErrorVarsCols]
# df_possibleErrorVarsfctr <- cbind(possibleErrorVarsfctr_df, df$crp_aliquot_fctr)
# TOne(df_possibleErrorVarsfctr, grp = df$crp_aliquot_fctr, add.length = T, total = T, # need to find which categorical variable is causing an error here. colnames(df[! colnames(df[varsToSummarise]) %in% colnames(df[varsToCompare])])
#      FUN = function(x) gettextf("%s (%s); %s (%s)",
#             Format(mean(x, na.rm = T), digits = 3),
#             Format(sd(x, na.rm = T), digits = 3),
#             Format(median(x, na.rm = T), digits = 3),
#             Format(IQR(x, na.rm = T), digits = 3)),
#      TEST = list(
#             num  = list(fun = function(x, g){summary(aov(x ~ g))[[1]][1, "Pr(>F)"]},
#                         lbl = "ANOVA"),
#             cat  = list(fun = function(x, g){chisq.test(table(x, g))$p.val},
#                         lbl = "Chi-Square test"),
#             dich = list(fun = function(x, g){chisq.test(table(x, g))$p.val},
#                         lbl = "Chi-Square test")), 
#            fmt = list(abs  = Fmt("abs"), 
#                    num  = Fmt("num"), 
#                    per  = Fmt("per"),
#                    pval = as.fmt(fmt = "p*")))
# 
# TOne(df[df_possibleErrorVars], grp = df$crp_aliquot_fctr, add.length = T, total = T, # need to find which categorical variable is causing an error here. colnames(df[! colnames(df[varsToSummarise]) %in% colnames(df[varsToCompare])])
#      FUN = function(x) gettextf("%s (%s); %s (%s)",
#             Format(mean(x, na.rm = T), digits = 3),
#             Format(sd(x, na.rm = T), digits = 3),
#             Format(median(x, na.rm = T), digits = 3),
#             Format(IQR(x, na.rm = T), digits = 3)),
#      TEST = list(
#             num  = list(fun = function(x, g){summary(aov(x ~ g))[[1]][1, "Pr(>F)"]},
#                         lbl = "ANOVA"),
#             cat  = list(fun = function(x, g){chisq.test(table(x, g))$p.val},
#                         lbl = "Chi-Square test"),
#             dich = list(fun = function(x, g){fisher.test(table(x, g))$p.val},
#                         lbl = "fisher exact test")), 
#            fmt = list(abs  = Fmt("abs"), 
#                    num  = Fmt("num"), 
#                    per  = Fmt("per"),
#                    pval = as.fmt(fmt = "p*")))

numVars <- c((which(colnames(df) %in% colnames(df_numVars))), which(colnames(df) == "date_assess0_t0"), which(colnames(df) == "date_assess2_t2"), which(colnames(df) == "cog_timeCompleted_t2"), which(colnames(df) == "brain_timeCompleted_t2"), which(colnames(df) == "crp_timeCollected_t0"), which(colnames(df) == "crp_assaydate_t0"))
# df_retained <- read_csv("/home/doodlefish/Documents/Research/LepageLab/immunologyAndSz/Analysis/immunoCognition/UKBB_dfRetained_03_21_2022.csv", guess_max = 10000) # import df
# df <- df_retained
```
# finalize vars for analysis
## Correlations between diet variables

```{r correlDietVars, echo=FALSE}
# diet_numeric <- c()
# for(i in dietVarsToCor){
#   if(is.numeric(df[[i]]) == T){
#     diet_numeric <- append(diet_numeric,i)
#   } 
# }
# 
# out <- matrix(ncol = 6, dimnames = list(c(),c("x,y","rho","p","stat", "nx", "ny"))) # initilaize output matrix
# VarsDone <- c()
# for(i in diet_numeric){
#   VarsDone <- append(VarsDone, i)
#   for(j in diet_numeric){
#     if(i != j){
#         test <- cor.test(df[[i]], df[[j]], method = 'spearman')
#         corName <- paste(colnames(df[i]), ", ", colnames(df[j]), sep = "")
#         nx <- length(df[[i]]) - sum(is.na(df[[i]]))
#         ny <- length(df[[j]]) - sum(is.na(df[[j]]))
#         newRow <- c(corName,format(round(test$estimate, 5), nsmall = 5), format(round(test$p.value, 2), scientific = T), format(round(test$statistic, 2),scientific = T), nx, ny)
#         out <- rbind(out, {newRow})
#       }
#   }
#   test <- cor.test(rank(df$diet_processedMeat_t0), rank(df[[i]]), method = 'pearson')
#   corName <- paste("diet_processedMeat_t0,", colnames(df[i]), sep = "")
#   nx <- length(df$diet_processedMeat_t0) - sum(is.na(df$diet_processedMeat_t0))
#   ny <- length(df[[i]]) - sum(is.na(df[[i]]))
#   newRow <- c(corName,format(round(test$estimate, 5), nsmall = 5), format(round(test$p.value, 2), scientific = T), format(round(test$statistic, 2), scientific = T), nx, ny)
#   out <- rbind(out, {newRow})
# }
#   test <- cor.test(rank(df$diet_processedMeat_t0), rank(df$diet_cookedVeg_t0), method = 'pearson')
#   corName <- paste("diet_processedMeat_t0, diet_cookedVeg_t0")
#   nx <- length(df$diet_processedMeat_t0) - sum(is.na(df$diet_processedMeat_t0))
#   ny <- length(df$diet_cookedVeg_t0) - sum(is.na(df$diet_cookedVeg_t0))
#   newRow <- c(corName,format(round(test$estimate, 5), nsmall = 5), format(round(test$p.value, 2), scientific = T), format(round(test$statistic, 2), scientific = T), nx, ny)
#   out <- rbind(out, {newRow})
#   
#   test <- cor.test(rank(df$diet_processedMeat_t0), rank(df$diet_rawVeg_t0), method = 'pearson')
#   corName <- paste("diet_processedMeat_t0, diet_rawVeg_t0")
#   nx <- length(df$diet_processedMeat_t0) - sum(is.na(df$diet_processedMeat_t0))
#   ny <- length(df$diet_rawVeg_t0) - sum(is.na(df$diet_rawVeg_t0))
#   newRow <- c(corName,format(round(test$estimate, 5), nsmall = 5), format(round(test$p.value, 2), scientific = T), format(round(test$statistic, 2), scientific = T), nx, ny)
#   out <- rbind(out, {newRow})
#   
#   test <- cor.test(rank(df$diet_processedMeat_t0), rank(df$diet_water_t0), method = 'pearson')
#   corName <- paste("diet_processedMeat_t0, diet_water_t0")
#   nx <- length(df$diet_processedMeat_t0) - sum(is.na(df$diet_processedMeat_t0))
#   ny <- length(df$diet_water_t0) - sum(is.na(df$diet_water_t0))
#   newRow <- c(corName,format(round(test$estimate, 5), nsmall = 5), format(round(test$p.value, 2), scientific = T), format(round(test$statistic, 2), scientific = T), nx, ny)
#   out <- rbind(out, {newRow})
# 
# out <- out[-1,] # removes first column which is "NA"
# out <- out[order(out[,2], decreasing = T),]
# out <- out[-(seq(2,to=nrow(out),by=2)),]
# kable(out, caption = "Spearman correlation between diet variables")

```

```{r correlCRPVars, echo=FALSE}
# cor(df$crp_timeFasting_t0, log(df$crp_aliquot_t0))
# # plot(, log(df$crp_hourCollected))
# ggplot(data = df, aes(x = df$crp_timeFasting_t0, y = log(df$crp_hourCollected)))+ geom_count()
# cor(df$crp_hourCollected, df$crp_aliquot_t0)
# plot(df$crp_aliquot_fctr, df$crp_hourCollected)
```

## Data reduction

-PCA assumptions: --linear relationship between components

```{r cognitionPCA, echo=FALSE}
cogPCAVars <- which(colnames(df) %in% c("cog_numMem_maxDigitRemem_t2", "cog_TMT_numericDuration_t2", "cog_TMT_numericErrors_t2", "cog_TMT_alphanumDuration_t2", "cog_TMT_alphanumErrors_t2", "cog_matrix_cor_t2", "cog_reactiontime_mean_t2", "cog_tower_cor_t2", "cog_digsub_cor_t2"))

cogPCAOut <- PCACompute(df = df, vars = cogPCAVars)
# capture.output(unlist(cogPCAOut$rotation), fileName = paste("cognitionPCA_prelim", date, ".csv", sep = ""))
# write.table(cogPCAOut$rotation, fileName = paste("cognitionPCA_prelim", date, ".csv", sep = ""))
# lapply(cogPCAOut$rotation, function(x) write.table(data.frame(x), paste("cognitionPCA_prelim", date, ".csv", sep = "")))
# PCASave(cogPCAOut, fileName = "")
cogPCAOut
summary(cogPCAOut)
PCAPlot(PCAOut = cogPCAOut, name = "Cognition Principal Component Analysis")

```

The principal component analysis for the cognitive variables returns: `` {r} cogPCAOut` `` ```{r} summary(cogPCAOut)`

```{r applyCognitionPCA, echo=FALSE}
df <- PCAApply(df = df,PCAOut = cogPCAOut,componentsToRetain = 3,prefix = "cog")
df <- df %>% 
    rename(cog_PC_1 = "\"cog_PC_1\"") %>% 
    rename(cog_PC_2 = "\"cog_PC_2\"") %>% 
    rename(cog_PC_3 = "\"cog_PC_3\"")

df <- df %>%   
  mutate(cog_PC_1 = as.numeric(unlist(cog_PC_1))) %>% 
  mutate(cog_PC_2 = as.numeric(unlist(cog_PC_2))) %>% 
  mutate(cog_PC_3 = as.numeric(unlist(cog_PC_3)))


# df <- rename(df, cog_PCA_1 = `"cog_PC_1"`)
PCASave(PCAOut = cogPCAOut, fileName = "UKBB_CogPCA")
```

## Assumption checks
### Normality
```{r checkNormalityMain, echo=FALSE}
crp_fctrCol <- which(colnames(df) == "crp_aliquot_fctr")
brainVarsOfInt <- which(colnames(df) %in% c("brain_vol_brainSegNoVent_t2", "brain_vol_hippocamp_L_t2", "brain_vol_hippocamp_R_t2"))
cogPCOutputs <- starts_with("cog_PC", vars = colnames(df))
numMemCol <- which(colnames(df) == "cog_numMem_maxDigitRemem_t2")
looseCovars <- c("demo_sex_t0", "demo_ethnicity_t0",  "demo_age_assess0_t0", "demo_daysBtwAssess", "ses_townsend_t0", "med_SSRI0", "waistToHip", "diet_processedMeat_t0", "sleep_duration0_t0", "sleep_duration2_t2", "smoke_currently_t0", "exercise_IPAQActivityGroup_t0")
covars <- unlist(lapply(looseCovars, FUN = function(x) (which(colnames(df) == x))))

varsOfInterest <- c(crp_fctrCol, brainVarsOfInt, cogPCOutputs, numMemCol, covars) # list of variables used in correlation/mediation analyses
# length(colnames(df[varsOfInterest]))

# create list of non-factor numeric variables for normality check ----
numVarsOfInterest <- lapply(df[varsOfInterest], numNotFactor)
df_numVarsOfInt <- as.data.frame(do.call(cbind, numVarsOfInterest))
numVarsOfInterest <- (which(colnames(df) %in% colnames(df_numVarsOfInt)))
# numVarsOfInterest <- numVarsOfInterest[-which(numVarsOfInterest == 86)]

normalityPlotsCorrel <- mapply(normalCheck, df[numVarsOfInterest], colName = colnames(df[numVarsOfInterest]), colNum = numVarsOfInterest)

nonNormalVarsOfInt <- c(9,12,13,40, 106, 107, 108, 109)
# normalityPlotsCorrel_nonNorm <- mapply(normalCheck, df[nonNormalVarsOfInt], colName = colnames(df[nonNormalVarsOfInt]), colNum = nonNormalVarsOfInt)

## apply normality correction
### Split non-normal variables into tertiles
df <- df %>% 
  mutate(ses_townsend_t0_z = scale(df$ses_townsend_t0)) %>% # scale townsend score
  mutate(cog_PC_1_z = scale(df$cog_PC_1)) %>% # scale PC1 score
  mutate(cog_PC_2_z = scale(df$cog_PC_2)) %>% # scale PC2 score
  mutate(cog_PC_3_z = scale(df$cog_PC_3)) # scale PC3 score

df <- df %>% 
  mutate(demo_age_assess0_t0_tert = factor(cut2(df$demo_age_assess0_t0, g = 3), order = T)) %>% # split into tertiles
  mutate(sleep_duration0_t0_tert = factor(cut2(df$sleep_duration0_t0, g = 3), order = T)) %>%  # sleep duration 0, split into tertiles
  mutate(sleep_duration2_t2_tert = factor(cut2(df$sleep_duration2_t2, g = 3), order = T)) %>%  # sleep duration 2, split into tertiles
  mutate(ses_townsend_t0_tert = factor(cut2(df$ses_townsend_t0_z, g = 3), order = T)) %>%  # townsend, split into tertiles
  mutate(cog_PC_1_tert = factor(cut2(df$cog_PC_1_z, g = 3), order = T)) %>% # cognition principle component 1, split into tertiles
  mutate(cog_PC_2_tert = factor(cut2(df$cog_PC_2_z, g = 3), order = T)) %>% # cognition principle component 2, split into tertiles
  mutate(cog_PC_3_tert = factor(cut2(df$cog_PC_3_z, g = 3), order = T)) # cognition principle component 3, split into tertiles

normCorrected <- which(colnames(df) %in% c("demo_age_assess0_t0_tert", "ses_townsend_t0_tert", "sleep_duration0_t0_tert", "sleep_duration2_t2_tert", "cog_PC_1_tert", "cog_PC_2_tert", "cog_PC_3_tert"))

revisedvarsOfInterest <- c(varsOfInterest[! varsOfInterest %in% nonNormalVarsOfInt],normCorrected)

# standardize numeric variables of interest
numRevisedVarsOfInt <- lapply(df[revisedvarsOfInterest], numNotFactor) # I want this to return a list of names that are not null
df_numRevisedVarsOfInt <- as.data.frame(do.call(cbind, numRevisedVarsOfInt))
revisedvarsOfInterest <- c()
for(i in colnames(df_numRevisedVarsOfInt)){
 revisedvarsOfInterest <- c(revisedvarsOfInterest, i)
}
revisedVarsColnums <- which(colnames(df) %in% revisedvarsOfInterest)
  
df_z <- df %>% mutate("{colnames(df[revisedVarsColnums])}_z" = across(.cols = revisedVarsColnums, .fns = scale))

df_numRevisedVarsOfInt <- as.data.frame(do.call(cbind, numRevisedVarsOfInt))
df_numVarsInt_z <- c()
df_numVarsInt_z <- df_numRevisedVarsOfInt %>% 
  mutate(across(colnames(df_numRevisedVarsOfInt), scale, .names = "{colnames(df_numRevisedVarsOfInt)}_z"))

scaledVarNames <- ends_with("_z", vars = colnames(df_numVarsInt_z))

df <- as.data.frame(cbind(df, df_numVarsInt_z[scaledVarNames]))
```
# Save DF
```{r saveDfFinal, echo=FALSE}
write.csv(df, file = paste("UKBB_dfForAnal_", date, ".csv", sep = "")) # exports cleaned dataframe with all variables ready for analysis
getwd()
```

```{r printRSessionInfo, echo=FALSE}
sessionInfo()
```